<div id="multiple-choice" class="greek tab-pane" role="tabpanel">
  <div class="chapters-container">
    <div class="chapter-container">
      <select id="mc-chapter-start" class="form-control">
      {% for ch in chapters %}
        <option value="{{ch}}">
          Chapter {{ch}}
        </option>
      {% endfor %}
      </select>
    </div>
    <div class="text-center chapter-text">
      to
    </div>
    <div class="chapter-container">
      <select id="mc-chapter-end" class="form-control" >
      {% for ch in chapters %}
        <option value="{{ch}}">
          Chapter {{ch}}
        </option>
      {% endfor %}
      </select>
    </div>
  </div>
  <div id="multiple-choice-container">
    <div id="mc-greek-vocab"></div>
    <div id="mc-options"></div>
    <div id="mc-result"></div>
  </div>
  <div>
    <button id="previous-vocab" class="btn btn-default">
      Previous
    </button>
    <button id="next-vocab" class="btn btn-primary">
      Next
    </button>
  </div>
  <div class="foot">
    <div id="multiple-choice-meta-data">
      Current result:
      <span id="current-result"></span>
      <span id="new-round">New Round!</span>
    </div>
  </div>
</div>

<script type="text/javascript">
  const optionLetters = ["A", "B", "C", "D"];
  let startingChapter_mc = 1;
  let endingChapter_mc = 1;
  let greekVocabList_mc = [];
  let currentVocabIdx_mc = 0;
  let options = [];
  let correctOption = undefined;
  let correctNumbers = 0; // number of questions that is correct

  // Check if an object is contained in a given array
  // Input: an array of objects, the object you want to check
  // Output: boolean
  function containsObject(arr, obj) {
    for (let i = 0; i < arr.length; i ++) {
      let isEqual = _.isEqual(arr[i], obj); // deep comparison
      if (isEqual) {
        return true
      }
    }
    return false;
  }

  function updateVocabList_mc() {
    $.ajax({
      type: "GET",
      url: updateChapUrl, // defined in index.html
      dataType: "json",
      data: {
        "startingChapter": startingChapter_mc,
        "endingChapter": endingChapter_mc,
      },
      success: function (data) {
        greekVocabList_mc = shuffleCards(data, data.length);
        // reset current index
        currentVocabIdx_mc = 0;
        correctNumbers = 0;
        resetCurrentVocab();
        updateQuestion();
        updateCurrentResult();
      }
    });
  }

  function changeStartingChapter_mc() {
    startingChapter_mc = document.getElementById("mc-chapter-start").value;
    // if the new starting chapter is greater than the ending chapter,
    // do not update Greek vocabs
    if (startingChapter_mc > endingChapter_mc) {
      return;
    }
    updateVocabList_mc();
  }

  function changeEndingChapter_mc() {
    endingChapter_mc = document.getElementById("mc-chapter-end").value;
    // if the new ending chapter is smaller than the starting chapter,
    // do not update greek vocabs
    if (endingChapter_mc < startingChapter_mc) {
      return;
    }
    updateVocabList_mc();
  }

  function startNewRound() {
    currentVocabIdx_mc = 0;
    correctNumbers = 0;
    greekVocabList_mc = greekVocabList_mc.filter((vocab) => {
      if (vocab.isCorrect) {
        return false; // filter out the vocab that was correct
      }
      return true;
    });

    // let the user know that it is a new round
    $("#new-round").fadeIn();
    $("#new-round").fadeOut(2000);
  }

  function resetCurrentVocab() {
    options = [];
    // clear the previous options
    $("#mc-options").text("");
    $("#mc-result").text("");
  }

  function updateQuestion() {
    if (greekVocabList_mc.length == 0) {
      passed();
      updateCurrentResult();
      return;
    }

    resetCurrentVocab();

    // update Greek vocab
    $("#mc-greek-vocab").text(`${currentVocabIdx_mc+1}. ${greekVocabList_mc[currentVocabIdx_mc].fields.greek}`);

    // update options
    // generate three random integers that is different than the current index and is not in the options yet
    for (let i = 0; i < 4; i++) {
      // A random number between min and max (both included)
      // Math.floor(Math.random() * (max - min + 1) ) + min
      let rand;
      do {
        rand = Math.floor(Math.random() *greekVocabList_mc.length);
      } while (rand == currentVocabIdx_mc || containsObject(options, greekVocabList_mc[rand]))
      options.push(greekVocabList_mc[rand]);
    }
    // put the correct randomly to the options
    correctOption = Math.floor(Math.random() * (3 + 1));
    options.splice(correctOption, 1, greekVocabList_mc[currentVocabIdx_mc]);

    // show the new options
    for (let i = 0; i < options.length; i++) {
      let optionValue = options[i].fields.english;
      $("#mc-options").append(`<input type="radio" name='mc-options' value="${optionValue}">&nbsp;&nbsp;${optionLetters[i]}. ${optionValue}<br/>`);
    }
  }

  function checkAnswer() {
    let selectedOption = $("input[name='mc-options']:checked").val();

    if (selectedOption == greekVocabList_mc[currentVocabIdx_mc].fields.english) { // correct
      $("#mc-result").text("Correct!");
      $("#mc-result").css("color", "#095f80");
      if (!greekVocabList_mc[currentVocabIdx_mc].isCorrect) {
        correctNumbers += 1;
      }
      greekVocabList_mc[currentVocabIdx_mc].isCorrect = true;
    } else { // wrong
      $("#mc-result").text(`Correct answer ${optionLetters[correctOption]}`);
      $("#mc-result").css("color", "#e85328");
    }
  }

  function updateCurrentResult() {
    $("#current-result").text(`${correctNumbers}/${greekVocabList_mc.length} correct`);
  }

  function previousVocab() {
    if (currentVocabIdx_mc > 0) {
      resetCurrentVocab();
      currentVocabIdx_mc -= 1;
      updateQuestion();
    }
  }

  function nextVocab() {
    if (greekVocabList_mc.length == 0) {
      passed();
      updateCurrentResult();
      return;
    }

    resetCurrentVocab();

    if (currentVocabIdx_mc >= greekVocabList_mc.length - 1) {
      startNewRound();
    } else {
      currentVocabIdx_mc += 1;
    }
    updateQuestion();
    updateCurrentResult();
  }

  // TODO: not showing the instant result, but showing the result later on in the report.

  // This function is called if all the vocab is passed.
  // Show the report
  function passed() {
    // check if the vocab list is empty
    if (greekVocabList_mc.length > 0) {
      return;
    }
    $("#mc-greek-vocab").text("Praise the Lord! You passed!");
    $("#mc-options").text("");
    $("#mc-result").text("");
  }

  $(document).ready(function() {
    updateVocabList_mc();
    $("#mc-chapter-start").on("change", changeStartingChapter_mc);
    $("#mc-chapter-end").on("change", changeEndingChapter_mc);
    $("#mc-options").on("change", checkAnswer);
    $("#previous-vocab").click(previousVocab);
    $("#next-vocab").click(nextVocab);
  });
</script>