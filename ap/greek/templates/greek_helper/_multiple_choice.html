<div id="multiple-choice" class="greek tab-pane" role="tabpanel">
  <div class="chapters-container">
    <div class="chapter-container">
      <select id="mc-chapter-start" class="form-control">
      {% for ch in chapters %}
        <option value="{{ch}}">
          Chapter {{ch}}
        </option>
      {% endfor %}
      </select>
    </div>
    <div class="text-center chapter-text">
      to
    </div>
    <div class="chapter-container">
      <select id="mc-chapter-end" class="form-control" >
      {% for ch in chapters %}
        <option value="{{ch}}">
          Chapter {{ch}}
        </option>
      {% endfor %}
      </select>
    </div>
  </div>
  <div id="multiple-choice-container">
    <div>
      <div id="mc-greek-vocab"></div>
      <div id="mc-options"></div>
      <div id="mc-result"></div>
    </div>
    <div>
      <button id="previous-vocab" class="btn btn-default">
        Previous
      </button>
      <button id="next-vocab" class="btn btn-primary">
        Next
      </button>
    </div>
    <div class="foot">
      <div id="multiple-choice-meta-data">
        Current result:
        <span id="current-result"></span>
      </div>
    </div>
  </div>
  <div id="multiple-choice-report-container">
    <table class="table table-hover">
      <thead>
        <tr>
        <th>GREEK</th>
        <th>ENGLISH</th>
        <th>WHAT YOU PICKED</th>
        <th>INCLUDED IN NEXT PRACTICE?</th>
      </tr>
      </thead>
      <tbody id="multiple-choice-report-body"></tbody>
    </table>
    <div>
      <button id="next-practice" class="btn btn-primary">Next Practice</button>
    </div>
  </div>
  <div id="you-passed">You passed!</div>
</div>

<script type="text/javascript">
  const optionLetters = ["A", "B", "C", "D"];
  let startingChapter_mc = 1;
  let endingChapter_mc = 1;
  let greekVocabList_mc = [];
  let greekVocabList_const = []; // this list only changes when an ajax is called
  let currentVocabIdx_mc = 0;
  let options = [];
  let correctOption = undefined;
  let correctNumbers = 0; // number of questions that is correct

  // Check if an object is contained in a given array
  // Input: an array of objects, the object you want to check
  // Output: boolean
  function containsObject(arr, obj) {
    for (let i = 0; i < arr.length; i ++) {
      let isEqual = _.isEqual(arr[i], obj); // deep comparison
      if (isEqual) {
        return true
      }
    }
    return false;
  }

  function updateVocabList_mc() {
    $.ajax({
      type: "GET",
      url: updateChapUrl, // defined in index.html
      dataType: "json",
      data: {
        "startingChapter": startingChapter_mc,
        "endingChapter": endingChapter_mc,
      },
      success: function (data) {
        greekVocabList_const = data;
        greekVocabList_mc = shuffleCards(data, data.length);// defined in index.html

        /*
            greekVocabList_mc data structure
            [{
              fields: {greek: "<Greek>", english: "<English>"},
              whatUserPicked: "<English>", // only record the option that the user picked at the first time
              tryAgain: true/false,
              ...
            }, ... ]
        */

        // reset current index
        currentVocabIdx_mc = 0;
        correctNumbers = 0;
        resetCurrentVocab();
        updateQuestion();
        $("#multiple-choice-container").show();
        $("#you-passed").hide();
      }
    });
  }

  function changeStartingChapter_mc() {
    startingChapter_mc = document.getElementById("mc-chapter-start").value;
    // if the new starting chapter is greater than the ending chapter,
    // change the ending chapter to be the same as starting chapter
    if (startingChapter_mc > endingChapter_mc) {
      $("#mc-chapter-end").val(startingChapter_mc);
      endingChapter_mc = startingChapter_mc;
    }
    updateVocabList_mc();
  }

  function changeEndingChapter_mc() {
    endingChapter_mc = document.getElementById("mc-chapter-end").value;
    // if the new ending chapter is smaller than the starting chapter,
    // do not update greek vocabs
    if (endingChapter_mc < startingChapter_mc) {
      return;
    }
    updateVocabList_mc();
  }

  function resetCurrentVocab() {
    options = [];
    // clear the previous options
    $("#mc-options").text("");
    $("#mc-result").html("&nbsp;");
  }

  function updateQuestion() {
    if (greekVocabList_mc.length == 0) {
      passed();
      updateCurrentResult();
      return;
    }

    resetCurrentVocab();

    // 1. update Greek vocab
    $("#mc-greek-vocab").text(`${currentVocabIdx_mc+1}. ${greekVocabList_mc[currentVocabIdx_mc].fields.greek}`);

    // 2. update options
    // generate three random integers that is different than the current index and is not in the options yet
    for (let i = 0; i < 4; i++) {
      // A random number between min and max (both included)
      // Math.floor(Math.random() * (max - min + 1) ) + min
      let rand;
      do {
        rand = Math.floor(Math.random() * greekVocabList_const.length);
      } while (rand == currentVocabIdx_mc || containsObject(options, greekVocabList_const[rand]))
      options.push(greekVocabList_const[rand]);
    }
    // put the correct answer randomly to the options
    correctOption = Math.floor(Math.random() * (3 + 1));
    options.splice(correctOption, 1, greekVocabList_mc[currentVocabIdx_mc]);
    // show the new options
    for (let i = 0; i < options.length; i++) {
      let optionValue = options[i].fields.english;
      $("#mc-options").append(`<input type="radio" name='mc-options' value="${optionValue}">&nbsp;&nbsp;${optionLetters[i]}. ${optionValue}<br/>`);
    }

    // 3. update the current score
    updateCurrentResult();
  }

  function changeOption() {
    const vocab = greekVocabList_mc[currentVocabIdx_mc];
    let selectedOption = $("input[name='mc-options']:checked").val();

    if (vocab.whatUserPicked == undefined) {
      vocab.whatUserPicked = `${selectedOption}`;
      if (selectedOption == vocab.fields.english) { // correct
        correctNumbers += 1;
        vocab.tryAgain = false;
      } else { // wrong
        vocab.tryAgain = true;
      }
    }

    if (selectedOption == vocab.fields.english) { // correct
      $("#mc-result").text("Correct!");
      $("#mc-result").css("color", "#095f80");
    } else { // wrong
      $("#mc-result").text(`Correct answer ${optionLetters[correctOption]}`);
      $("#mc-result").css("color", "#e85328");
    }
  }

  function updateCurrentResult() {
    $("#current-result").text(`${correctNumbers}/${greekVocabList_mc.length} correct`);
  }

  function previousVocab() {
    if (currentVocabIdx_mc > 0) {
      resetCurrentVocab();
      currentVocabIdx_mc -= 1;
      updateQuestion();
    }
  }

  function nextVocab() {
    // if no more vocab in the list, the user passed the practice
    if (greekVocabList_mc.length == 0) {
      passed();
      updateCurrentResult();
      return;
    }

    resetCurrentVocab();

    if (currentVocabIdx_mc < greekVocabList_mc.length - 1) {
      currentVocabIdx_mc += 1;
      updateQuestion();
    } else {
      showReport();
    }
  }

  function showReport() {
    $("#multiple-choice-container").hide();
    $("#multiple-choice-report-container").show();
    for (let i = 0; i < greekVocabList_mc.length; i++) {
      const vocab = greekVocabList_mc[i];
      const isCorrect = vocab.fields.english == vocab.whatUserPicked;
      const rowColor = isCorrect ? "success" : (vocab.whatUserPicked ? "danger" : "");
      $("#multiple-choice-report-body").append(
        `<tr class="${rowColor}">
          <td>${vocab.fields.greek}</td>
          <td>${vocab.fields.english}</td>
          <td>${vocab.whatUserPicked || ""}</td>
          <td>
            <input class="checkbox-vocab" type="checkbox" onclick=changeVocabFlag(${i}) ${vocab.tryAgain || vocab.tryAgain == undefined ? "checked" : ""}>
          </td>
        </tr>`
        );
    }
  }

  function changeVocabFlag(index) {
    const vocab = greekVocabList_mc[index];
    vocab.tryAgain = !vocab.tryAgain;
  }

  function nextPractice() {
    $("#multiple-choice-container").show();
    $("#multiple-choice-report-container").hide();

    currentVocabIdx_mc = 0;
    correctNumbers = 0;
    greekVocabList_mc = greekVocabList_mc.filter((vocab) => {
      // vocab.tryAgain is undefined means the user never select any option for this vocab
      if (vocab.tryAgain || vocab.tryAgain == undefined) {
        delete vocab.tryAgain;
        delete vocab.whatUserPicked;
        return true;
      }
      return false;
    });

    // clear the report table
    $("#multiple-choice-report-body").empty();

    updateQuestion();
  }

  // This function is called if all the vocab is passed.
  function passed() {
    // check if the vocab list is empty
    if (greekVocabList_mc.length > 0) {
      return;
    }
    $("#multiple-choice-container").hide();
    $("#multiple-choice-report-container").hide();
    $("#you-passed").show();
  }

  $(document).ready(function() {
    updateVocabList_mc();
    $("#mc-chapter-start").on("change", changeStartingChapter_mc);
    $("#mc-chapter-end").on("change", changeEndingChapter_mc);
    $("#mc-options").on("change", changeOption);
    $("#previous-vocab").click(previousVocab);
    $("#next-vocab").click(nextVocab);
    $("#next-practice").click(nextPractice);
  });
</script>