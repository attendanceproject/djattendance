<div id="multiple-choice" class="greek tab-pane" role="tabpanel">
  <div class="chapters-container">
    <div class="chapter-container">
      <select id="mc-chapter-start" class="form-control">
      {% for ch in chapters %}
        <option value="{{ch}}">
          Chapter {{ch}}
        </option>
      {% endfor %}
      </select>
    </div>
    <div class="text-center chapter-text">
      to
    </div>
    <div class="chapter-container">
      <select id="mc-chapter-end" class="form-control" >
      {% for ch in chapters %}
        <option value="{{ch}}">
          Chapter {{ch}}
        </option>
      {% endfor %}
      </select>
    </div>
  </div>
  <div id="multiple-choice-report-container">
    <div id="multiple-choice-container">
      <div id="mc-greek-vocab"></div>
      <div id="mc-options"></div>
      <div id="mc-result"></div>
    </div>
    <div>
      <button id="previous-vocab" class="btn btn-default">
        Previous
      </button>
      <button id="next-vocab" class="btn btn-primary">
        Next
      </button>
    </div>
    <div class="foot">
      <div id="multiple-choice-meta-data">
        Current result:
        <span id="current-result"></span>
        <span id="new-round">New Round!</span>
      </div>
    </div>
  </div>
  <div>
    <table class="table table-hover">
      <thead>
        <tr>
        <th>Greek</th>
        <th>English</th>
        <th>What you picked</th>
        <th>Included in next practice?</th>
      </tr>
      </thead>
      <tbody id="multiple-choice-report-body"></tbody>
    </table>
    <div>
      <button id="next-practice" class="btn btn-primary">Next Practice</button>
    </div>
  </div>
</div>

<script type="text/javascript">
  const optionLetters = ["A", "B", "C", "D"];
  let startingChapter_mc = 1;
  let endingChapter_mc = 1;
  let greekVocabList_mc = [];
  let greekVocabList_const = []; // this list only changes when an ajax is called
  let currentVocabIdx_mc = 0;
  let options = [];
  let correctOption = undefined;
  let correctNumbers = 0; // number of questions that is correct

  // Check if an object is contained in a given array
  // Input: an array of objects, the object you want to check
  // Output: boolean
  function containsObject(arr, obj) {
    for (let i = 0; i < arr.length; i ++) {
      let isEqual = _.isEqual(arr[i], obj); // deep comparison
      if (isEqual) {
        return true
      }
    }
    return false;
  }

  function updateVocabList_mc() {
    $.ajax({
      type: "GET",
      url: updateChapUrl, // defined in index.html
      dataType: "json",
      data: {
        "startingChapter": startingChapter_mc,
        "endingChapter": endingChapter_mc,
      },
      success: function (data) {
        greekVocabList_const = data;
        greekVocabList_mc = shuffleCards(data, data.length);// defined in index.html

        // TODO: remove this. this is just for testing
        greekVocabList_mc = greekVocabList_mc.slice(0, 5);
        /*
            greekVocabList_mc data structure
            [{
              fields: {greek: "<Greek>", english: "<English>"},
              isCorrect: true/false,
              wrongAnswer: "<English>", // only has this field if the user picked the wrong option at the first time
              tryAgain: true/false,
              ...
            }, ... ]
        */

        // reset current index
        currentVocabIdx_mc = 0;
        correctNumbers = 0;
        resetCurrentVocab();
        updateQuestion();
        updateCurrentResult();
      }
    });
  }

  function changeStartingChapter_mc() {
    startingChapter_mc = document.getElementById("mc-chapter-start").value;
    // if the new starting chapter is greater than the ending chapter,
    // change the ending chapter to be the same as starting chapter
    if (startingChapter_mc > endingChapter_mc) {
      $("#mc-chapter-end").val(startingChapter_mc);
      endingChapter_mc = startingChapter_mc;
    }
    updateVocabList_mc();
  }

  function changeEndingChapter_mc() {
    endingChapter_mc = document.getElementById("mc-chapter-end").value;
    // if the new ending chapter is smaller than the starting chapter,
    // do not update greek vocabs
    if (endingChapter_mc < startingChapter_mc) {
      return;
    }
    updateVocabList_mc();
  }

  function resetCurrentVocab() {
    options = [];
    // clear the previous options
    $("#mc-options").text("");
    $("#mc-result").text("");
  }

  function updateQuestion() {
    if (greekVocabList_mc.length == 0) {
      passed();
      updateCurrentResult();
      return;
    }

    resetCurrentVocab();

    // update Greek vocab
    $("#mc-greek-vocab").text(`${currentVocabIdx_mc+1}. ${greekVocabList_mc[currentVocabIdx_mc].fields.greek}`);

    // update options
    // generate three random integers that is different than the current index and is not in the options yet
    for (let i = 0; i < 4; i++) {
      // A random number between min and max (both included)
      // Math.floor(Math.random() * (max - min + 1) ) + min
      let rand;
      do {
        rand = Math.floor(Math.random() * greekVocabList_const.length);
      } while (rand == currentVocabIdx_mc || containsObject(options, greekVocabList_const[rand]))
      options.push(greekVocabList_const[rand]);
    }
    // put the correct answer randomly to the options
    correctOption = Math.floor(Math.random() * (3 + 1));
    options.splice(correctOption, 1, greekVocabList_mc[currentVocabIdx_mc]);

    // show the new options
    for (let i = 0; i < options.length; i++) {
      let optionValue = options[i].fields.english;
      $("#mc-options").append(`<input type="radio" name='mc-options' value="${optionValue}">&nbsp;&nbsp;${optionLetters[i]}. ${optionValue}<br/>`);
    }
  }

  function changeOption() {
    const vocab = greekVocabList_mc[currentVocabIdx_mc];
    let selectedOption = $("input[name='mc-options']:checked").val();
    if (selectedOption == vocab.fields.english) { // correct
      $("#mc-result").text("Correct!");
      $("#mc-result").css("color", "#095f80");
      if (!vocab.isCorrect) {
        correctNumbers += 1; // only increment this value once for each vocab
      }
      vocab.isCorrect = true;
      vocab.tryAgain = false;
    } else { // wrong
      $("#mc-result").text(`Correct answer ${optionLetters[correctOption]}`);
      $("#mc-result").css("color", "#e85328");
      vocab.wrongAnswer = `${selectedOption}`;
      vocab.tryAgain = true;
    }
  }

  function updateCurrentResult() {
    $("#current-result").text(`${correctNumbers}/${greekVocabList_mc.length} correct`);
  }

  function previousVocab() {
    if (currentVocabIdx_mc > 0) {
      resetCurrentVocab();
      currentVocabIdx_mc -= 1;
      updateQuestion();
    }
  }

  function nextVocab() {
    if (greekVocabList_mc.length == 0) {
      passed();
      updateCurrentResult();
      return;
    }

    resetCurrentVocab();

    if (currentVocabIdx_mc < greekVocabList_mc.length - 1) {
      currentVocabIdx_mc += 1;
      updateQuestion();
      updateCurrentResult();
    } else {
      showReport();
    }
  }

  function showReport() {
    // TODO: delete the previous report
    for (let i = 0; i < greekVocabList_mc.length; i++) {
      // TODO: build the report
      // color coded. correct, green, wrong red.
      const vocab = greekVocabList_mc[i];
      const rowColor = vocab.wrongAnswer ? "danger" : "";
      $("#multiple-choice-report-body").append(
        `<tr class="${rowColor}">
          <td>${vocab.fields.greek}</td>
          <td>${vocab.fields.english}</td>
          <td>${vocab.wrongAnswer || ""}</td>
          <td>
            <input class="checkbox-vocab" type="checkbox" onclick=changeVocabFlag(${i}) ${vocab.tryAgain ? "checked" : ""}>
          </td>
        </tr>`
        );
    }
    $("multiple-choice-report-container").show();
  }

  function changeVocabFlag(index) {
    const vocab = greekVocabList_mc[index];
    vocab.tryAgain = !vocab.tryAgain;
  }

  function nextPractice() {
    // TODO: clear the report table
    // TODO: hide the report table and button
    currentVocabIdx_mc = 0;
    correctNumbers = 0;
    greekVocabList_mc = greekVocabList_mc.filter((vocab) => {
      return vocab.tryAgain;
    });

    // let the user know that it is a new round
    $("#new-round").fadeIn();
    $("#new-round").fadeOut(2000);
    /*
    updateQuestion();
    updateCurrentResult();*/
  }

  // TODO: not showing the instant result, but showing the result later on in the report.

  // This function is called if all the vocab is passed.
  // Show the report
  function passed() {
    // check if the vocab list is empty
    if (greekVocabList_mc.length > 0) {
      return;
    }
    $("#mc-greek-vocab").text("Praise the Lord! You passed!");
    $("#mc-options").text("");
    $("#mc-result").text("");
  }

  $(document).ready(function() {
    updateVocabList_mc();
    $("#mc-chapter-start").on("change", changeStartingChapter_mc);
    $("#mc-chapter-end").on("change", changeEndingChapter_mc);
    $("#mc-options").on("change", changeOption);
    $("#previous-vocab").click(previousVocab);
    $("#next-vocab").click(nextVocab);
    $("#next-practice").click(nextPractice);
  });
</script>